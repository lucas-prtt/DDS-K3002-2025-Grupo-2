spring.application.name=interfaz-agregador

# Puerto para la INTERFAZ de registroUsuarioDto del agregador
server.port=8094
# Si esta en false, nomas se intenta registrar la primera vez tras la autenticacion. Si esta en true, ademas se intenta registrar si recibe 404 al hacer el GET de la cuenta en agregador
api.agregador.contribuyentes.register-if-not-found=false

# Apis
api.publica.url=${API_PUBLICA_URL:http://localhost:8085/apiPublica}
api.administrativa.url=${API_ADMINISTRATIVA_URL:http://localhost:8086/apiAdministrativa}

# Keycloak
keycloak.realm=metamapa
keycloak.admin-client.id=metamapa-admin-client
#keycloak.admin-client.secret=${KEYCLOAK_ADMIN_CLIENT_SECRET}
keycloak.url=${KEYCLOAK_URL:http://localhost:8888}
# ==========================================
# CONFIGURACIÓN DE SPRING SECURITY OAUTH2 CLIENT
# ==========================================

# --- Proveedor (Provider) ---
# Le dice a Spring dónde está nuestro servidor de autenticación (Keycloak)
spring.security.oauth2.client.provider.keycloak.issuer-uri=${KEYCLOAK_URL:http://localhost:8888}/realms/metamapa

# --- Registro del Cliente (Registration) ---
# Configura cómo esta aplicación específica se identifica ante Keycloak
spring.security.oauth2.client.registration.keycloak.client-id=metamapa-agregador-ui
spring.security.oauth2.client.registration.keycloak.client-secret=${KEYCLOAK_AGREGADOR_CLIENT_SECRET}
spring.security.oauth2.client.registration.keycloak.authorization-grant-type=authorization_code
# Para que pida usuario al re-loguear
spring.security.oauth2.client.provider.keycloak.authorization-uri=${KEYCLOAK_URL:http://localhost:8888}/realms/metamapa/protocol/openid-connect/auth?prompt=login

# Los 'scopes' definen qué información del registroUsuarioDto pedimos
spring.security.oauth2.client.registration.keycloak.scope=openid,profile,email
server.forward-headers-strategy=framework


# Permite recargar la pagina sin reiniciar la app. Se deberia quitar en produccion
spring.thymeleaf.cache=false
#spring.web.resources.static-locations=${STATIC_LOCATIONS:file:frontend/interfaz-agregador/src/main/resources/static/}
#spring.thymeleaf.prefix=${THYMELEAF_PREFIX:file:frontend/interfaz-agregador/src/main/resources/templates/}
#spring.thymeleaf.suffix=.html

# Expone endpoints para Prometheus
management.endpoints.web.exposure.include=health,info,prometheus,metrics
management.endpoint.prometheus.enabled=true

# Configuración de Zipkin (Trazas)
# Enviaremos las trazas al servidor Zipkin que levantaremos en Docker
management.zipkin.tracing.endpoint=${ZIPKIN_URL:http://localhost:9411/api/v2/spans}

# Configuración de Loki (Logs)
loki.url=${LOKI_URL:http://localhost:3100/loki/api/v1/push}

# Sampling (Muestreo)
# 1.0 significa: "Guarda el 100% de las peticiones".
# (En producción real se pone 0.1 para no llenar el disco, pero en Tesis usa 1.0)
management.tracing.sampling.probability=0.1
server.servlet.session.timeout=60m

# Eureka
eureka.client.service-url.defaultZone=${EUREKA_CLIENT_SERVICE_URL_DEFAULTZONE:http://localhost:8761/eureka/}
eureka.instance.hostname=${EUREKA_INSTANCE_HOSTNAME:localhost}
eureka.client.fetch-registry=true
eureka.client.register-with-eureka=true
eureka.instance.prefer-ip-address=true
